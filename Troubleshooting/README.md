## Задача 1

---
* Предположим, что средства профилирования уже включены. 
Поэтому запустим поиск запросов, которые длятся дольше 3 минут, в базе данных "db1"

```
db.currentOp(
   {
     "active" : true,
     "secs_running" : { "$gt" : 180 },
     "ns" : /^db1\./
   }
)
```
После можно убить процесс, если происходит SELECT, другая операция может поломать БД.

```
db.killOp(<opid of the query to kill>)
```

*  Можно так же найти запросы, которые выполняются слишком медленно,
   А после с помощью explain построить план выполнения этих запросов и дальше уже смотреть, 
   возможно выбирается слишком широкий охват и нужно сужать запрос и добавить индексы.
*  Либо установить ограничение на максимальное время обработки операций

   ```
   maxTimeMS ()
   ```


## Задача 2

---
При масштабировании реплик будет загружена сеть из-за перекачки данных,
скорее всего заканчивается оперативная память.
Redis не успевает удалять старые ключи, если их много и их срок действия заканчивается в один и тот же момент.

### Задача 3

---
Увеличилось время обработки запроса, потому что стало больше записей.
Нужно либо оптимизировать запрос, либо увеличить время подключения к БД на стороне клиента или сервера.


### Задача 4

---

Не хватает оперативной памяти нужно увеличить ее объем, а потом уже искать кто виноват.
Можно поиграть с параметрами, которые регулируют память в Postgres из основных это: max_connections, shared_buffer, work_mem, effective_cache_size, maintenance_work_mem.

shared_buffer - этот параметр устанавливает, сколько выделенной памяти будет использоваться PostgreSQL для кеширования.

wal_buffers - PostgreSQL сначала записывает записи в WAL (журнал пред записи) в буферы, а затем эти буферы сбрасываются на диск. Размер буфера по умолчанию, определенный wal_buffers, составляет 16 МБ. Но если у нас много одновременных подключений, то более высокое значение может повысить производительность.

effective_cache_size - предоставляет оценку памяти, доступной для кэширования диска. Это всего лишь ориентир, а не точный объем выделенной памяти или кеша. Он не выделяет фактическую память, но сообщает оптимизатору объем кеша, доступный в ядре. Если значение этого параметра установлено слишком низким, планировщик запросов может принять решение не использовать некоторые индексы, даже если они будут полезны. Поэтому установка большого значения всегда имеет смысл.

work_mem - если нам нужно выполнить сложную сортировку, увеличьте значение work_mem для получения хороших результатов. Сортировка в памяти происходит намного быстрее, чем сортировка данных на диске. Установка очень высокого значения может стать причиной узкого места в памяти для нашей среды, поскольку этот параметр относится к операции сортировки пользователя.

maintenance_work_mem - это параметр памяти, используемый для задач обслуживания.


